#!/usr/bin/python3

## ============================================================================
##             **** Murasame Application Development Framework ****
##                Copyright (C) 2019-2021, Suisei Entertainment
## ============================================================================
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
## ============================================================================

"""
Build script to build the Murasame framework.

Args:
    type:   The type of build to run. Potential values:
                - development: [DEFAULT] Create a development build for
                               internal use.
                - release: Create a releaes build and upload it to GitHub and
                           PyPi.

Authors:
    Attila Kovacs
"""

# Platform Imports
import os
import json
import argparse
import logging
import subprocess

from enum import IntEnum
from string import Template

COLOREDLOGS_AVAILABLE = False

# Dependency Imports
try:
    import coloredlogs
    COLOREDLOGS_AVAILABLE = True
except ImportError:
    COLOREDLOGS_AVAILABLE = False

## ============================================================================
##      >>> CONSTANTS <<<
## ============================================================================

"""
The template file used to generate the version file.
"""
VERSION_TEMPLATE_PATH = \
    os.path.abspath(os.path.expanduser('./scripts/version.conf.in'))

"""
The input file used to generate the version constant file.
"""
VERSION_CONSTANTS_TEMPLATE_PATH = \
    os.path.abspath(os.path.expanduser('./scripts/version.py.in'))

"""
The input file used to generate the setup script.
"""
SETUP_SCRIPT_TEMPLATE_PATH = \
    os.path.abspath(os.path.expanduser('./scripts/setup.py.in'))

"""
Path to the version file.
"""
VERSION_FILE_PATH = \
    os.path.abspath(os.path.expanduser('./version.conf'))

"""
Path to the version constants file.
"""
VERSION_CONSTANTS_PATH = \
    os.path.abspath(os.path.expanduser('./murasame/version.py'))

"""
Path to the setup script to use when building the Python wheel.
"""
SETUP_SCRIPT_PATH = \
    os.path.abspath(os.path.expanduser('./setup.py'))

"""
Path to the log file of the build script.
"""
LOG_FILE_PATH = \
    os.path.abspath(os.path.expanduser('~/.murasame/logs/build.log'))

"""
Path to the directory where the build output will be placed.
"""
DIST_PATH = \
    os.path.abspath(os.path.expanduser('~/.murasame/dist'))

## ============================================================================
##      >>> UTILITIES <<<
## ============================================================================

class BuildTypes(IntEnum):

    """
    List of supported build types.

    Authors:
        Attila Kovacs
    """

    DEVELOPMENT = 0     # Marks a development build
    RELEASE = 1         # Marks a release build

## ============================================================================
##      >>> BUILD LOGIC <<<
## ============================================================================

def bump_version_number() -> None:

    """
    Loads the version configuration file, increases the build number and saves
    it to be used by the rest of the build script.

    Authors:
        Attila Kovacs
    """

    logger = logging.getLogger('murasame.builder')
    logger.debug('[STEP #1] Increasing build number in version.conf...')

    # Open configuration file
    try:
        with open(VERSION_FILE_PATH, 'r') as config_file:
            version_data = json.load(config_file)
    except FileNotFoundError:
        logger.warning('[STEP #1]     - Version.conf doesn\'t exist yet, '
                       'creating it with default parameters..')
        with open(VERSION_TEMPLATE_PATH, 'r') as config_file:
            version_data = json.load(config_file)
    except OSError as error:
        logger.error('[STEP #1]     - Failed to read the contents of version.conf.')
        raise SystemExit from error
    except json.JSONDecodeError as error:
        logger.error('[STEP #1]     - Failed to parse the content of version.conf.')
        raise SystemExit from error

    # Bump the build number in regular builds, use the Travis build number if
    # the building is running in Travis CI
    is_travis = False
    try:
        temp = os.environ['TRAVIS']
        del temp
        is_travis = True
    except KeyError:
        is_travis = False

    if is_travis:
        logger.debug('[STEP #1]     - Build is running in Travis, using Travis build number.')
        try:
            build_num = int(os.environb['TRAVIS_BUILD_NUMBER'])
        except KeyError as error:
            logger.error('[STEP #1]     - Travis build number cannot be determined.')
            raise SystemExit from error
    else:
        logger.debug('[STEP #1]     - Running local build, bumping existing version number.')
        build_num = int(version_data['meta']['build'])
        build_num = build_num + 1

    # Set the new version number in the version configuration
    version_data['meta']['build'] = str(build_num)
    logger.debug(f'[STEP #1]     - New build number is {build_num}.')

    # Set the build type in the version configuration
    if is_travis:
        version_data['meta']['build_type'] = 'CI'
    else:
        version_data['meta']['build_type'] = 'local'

    # Save the version configuration
    try:
        with open(VERSION_FILE_PATH, 'w+') as config_file:
            json.dump(version_data,
                      config_file,
                      indent=4,
                      separators=(',', ': '))
    except OSError as error:
        logger.error('[STEP #1]     - Failed to update version.conf.')
        raise SystemExit from error

    logger.debug('[STEP #1] Build number has been updated.')

def create_constants_file() -> None:

    """
    Creates the version constants file to be included in the framework.

    Authors:
        Attila Kovacs
    """

    logger = logging.getLogger('murasame.builder')
    logger.debug('[STEP #2] Creating version constants file...')

    # Retrieving version data
    version_data = None
    major_version = None
    minor_version = None
    patch_level = None
    build_num = None
    build_type = None
    release_level = None
    release_codename = None
    scm_id = None

    # Open configuration file
    try:
        with open(VERSION_FILE_PATH, 'r') as config_file:
            version_data = json.load(config_file)
    except OSError as error:
        logger.error('[STEP #2]     - Failed to read the contents of version.conf.')
        raise SystemExit from error
    except json.JSONDecodeError as error:
        logger.error('[STEP #2]     - Failed to parse the content of version.conf.')
        raise SystemExit from error

    try:
        major_version = version_data['major']
        logger.debug(f'[STEP #2]     - Major version: {major_version}')
    except KeyError as error:
        logger.error('[STEP #2]     - No major version was found in version.conf')
        raise SystemExit from error

    try:
        minor_version = version_data['minor']
        logger.debug(f'[STEP #2]     - Minor version: {minor_version}')
    except KeyError as error:
        logger.error('[STEP #2]     - No minor version was found in version.conf')
        raise SystemExit from error

    try:
        patch_level = version_data['patch']
        logger.debug(f'[STEP #2]     - Patch level: {patch_level}')
    except KeyError as error:
        logger.error('[STEP #2]     - No patch level was found in version.conf')
        raise SystemExit from error

    try:
        build_num = version_data['meta']['build']
        logger.debug(f'[STEP #2]     - Build: {build_num}')
    except KeyError as error:
        logger.error('[STEP #2]     - No build number was found in version.conf')
        raise SystemExit from error

    try:
        build_type = version_data['meta']['build_type']
        logger.debug(f'[STEP #2]     - Build type: {build_type}')
    except KeyError as error:
        logger.error('[STEP #2]     - No build type was found in version.conf')
        raise SystemExit from error

    try:
        release_level = version_data['release']
        logger.debug(f'[STEP #2]     - Release level: {release_level}')
    except KeyError as error:
        logger.error('[STEP #2]     - No release level was found in version.conf')
        raise SystemExit from error

    try:
        release_codename = version_data['meta']['codename']
        logger.debug(f'[STEP #2]     - Release codename: {release_codename}')
    except KeyError as error:
        logger.error('[STEP #2]     - No release codename was found in version.conf')
        raise SystemExit from error

    # Retrieving SCM version
    try:
        scm_id = subprocess.check_output(
            ['git', 'rev-parse', 'HEAD']).strip().decode('ascii')
        logger.debug(f'[STEP #2]     - Git commit hash: {scm_id}')
    except subprocess.CalledProcessError as error:
        logger.error('Failed to determine the git commit hash.')
        raise SystemExit from error

    # Load the constats file template
    template_content = None
    try:
        with open(VERSION_CONSTANTS_TEMPLATE_PATH, 'r') as template_file:
            template_content = template_file.read()
    except OSError as error:
        logger.error('[STEP #2]     - Failed to read the contents of version.py.in')
        raise SystemExit from error

    # Create file content
    template = Template(template_content)
    version_content_string = template.safe_substitute(
        major_version=major_version,
        minor_version=minor_version,
        patch_level=patch_level,
        build_num=build_num,
        build_type=build_type,
        release_level=release_level,
        release_codename=release_codename,
        scm_id=scm_id)

    # Write the file
    with open(VERSION_CONSTANTS_PATH, 'w+') as version_file:
        version_file.write(version_content_string)

    logger.debug('[STEP #2] Version constants are added to the framework.')

def collect_packages() -> list:

    """
    Collects the packages of the framework to be added to the wheel.

    Returns:
        A list with all packages within the framework.

    Authors:
        Attila Kovacs
    """

    result = ['murasame']

    objects = os.scandir('./murasame')

    for obj in objects:
        if obj.is_dir() and obj.name != '__pycache__':
            result.append(f'murasame.{obj.name}')
            subdirs = os.scandir(f'./murasame/{obj.name}')
            for subdir in subdirs:
                if subdir.is_dir() and subdir.name != '__pycache__':
                    result.append(f'murasame.{obj.name}.{subdir.name}')

    return result

def collect_dependencies() -> list:

    """
    Collects the dependencies of the framework to be added to the setup script.

    Depedencies are identified by analyzing the requirements.txt file in the
    framework's repository.

    Returns:
        A list with all required dependencies.

    Authors:
        Attila Kovacs
    """

    result = []
    lines = None

    logger = logging.getLogger('murasame.builder')

    try:
        with open('./requirements.txt', 'r') as requirements:
            lines = requirements.readlines()
    except OSError as error:
        logger.error('[STEP #3]     - Failed to read the contents of requirements.txt')
        raise SystemExit from error

    for line in lines:
        if not line.startswith('#') and not line.startswith('\n'):
            result.append(line.strip().replace('\n', ''))

    return result

def create_wheel() -> None:

    """
    Creates the Python wheel.

    Authors:
        Attila Kovacs
    """

    logger = logging.getLogger('murasame.builder')
    logger.debug('[STEP #3] Creating Python wheel...')

    logger.debug('[STEP #3]     - Creating setup.py...')

    template = None

    # Retrieving version data
    version_data = None
    major_version = None
    minor_version = None
    patch_level = None

    # Open configuration file
    try:
        with open(VERSION_FILE_PATH, 'r') as config_file:
            version_data = json.load(config_file)
    except OSError as error:
        logger.error('[STEP #3]     - Failed to read the contents of version.conf.')
        raise SystemExit from error
    except json.JSONDecodeError as error:
        logger.error('[STEP #3]     - Failed to parse the content of version.conf.')
        raise SystemExit from error

    try:
        major_version = version_data['major']
        logger.debug(f'[STEP #3]     - Major version: {major_version}')
    except KeyError as error:
        logger.error('[STEP #3]     - No major version was found in version.conf')
        raise SystemExit from error

    try:
        minor_version = version_data['minor']
        logger.debug(f'[STEP #3]     - Minor version: {minor_version}')
    except KeyError as error:
        logger.error('[STEP #3]     - No minor version was found in version.conf')
        raise SystemExit from error

    try:
        patch_level = version_data['patch']
        logger.debug(f'[STEP #3]     - Patch level: {patch_level}')
    except KeyError as error:
        logger.error('[STEP #3]     - No patch level was found in version.conf')
        raise SystemExit from error

    # Load setup.py template
    try:
        with open(SETUP_SCRIPT_TEMPLATE_PATH, 'r') as setup_template:
            template = setup_template.read()
    except OSError as error:
        logger.error(f'[STEP #3]     - Failed to load the setup script '
                     f'template from {SETUP_SCRIPT_TEMPLATE_PATH}')
        raise SystemExit from error


    # Create file content
    template = Template(template)
    setup_string = template.safe_substitute(
        major_version=major_version,
        minor_version=minor_version,
        patch_level=patch_level,
        packages=collect_packages(),
        install_requires=collect_dependencies())

    # Write the file
    with open('./setup.py', 'w+') as setup_file:
        setup_file.write(setup_string)

    logger.debug('[STEP #3]     - Running setup.py...')
    try:
        subprocess.check_call(
            [\
                'python',
                'setup.py',
                'bdist_wheel',
                '--dist-dir', DIST_PATH,
                'clean'])
    except subprocess.CalledProcessError as error:
        logger.error('Failed to create wheel.')
        raise SystemExit from error

    logger.debug('[STEP #3] Python wheel created.')

def do_release() -> None:

    """
    Creates a realease from the current build on GitHub and PyPi.

    Authors:
        Attila Kovacs
    """

    logger = logging.getLogger('murasame.builder')
    logger.debug('[STEP #4] Releasing wheel...')

def parse_command_line() -> object:

    """
    Parses command line arguments.

    Authors:
        Attila Kovacs
    """

    parser = argparse.ArgumentParser(
        description='Build utility of the Murasame framework.')

    parser.add_argument('--type',
                        dest='release_type',
                        default='development',
                        action='store',
                        help='The type of the build to run.')

    return parser.parse_args()

## ============================================================================
##      >>> MAIN <<<
## ============================================================================

def main() -> None:

    """
    Contains the main build logic.

    Authors:
        Attila Kovacs
    """

    build_type = BuildTypes.DEVELOPMENT

    # Initialize logging
    logger = logging.getLogger('murasame.builder')
    logging.basicConfig(filename=LOG_FILE_PATH,
                        level=logging.DEBUG)
    if COLOREDLOGS_AVAILABLE:
        coloredlogs.install(level='DEBUG')

    # Process command line
    args = parse_command_line()

    if args.release_type == 'release':
        build_type = BuildTypes.RELEASE

    # Execute the build
    bump_version_number()
    create_constants_file()
    create_wheel()

    if build_type == BuildTypes.RELEASE:
        do_release()

if __name__ == '__main__':
    main()
